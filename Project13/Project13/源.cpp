/*题目：小球下落 （二叉树的应用）
题目描述：
有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右编号为1，2，3，...，2^D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，它的状态都会改变。当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否者往右走，直到走到叶子结点。
一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数（即2^(D-1)）。D<=20。输入最多包含1000组数据。
样例输入：
4 2
3 4
10 1
2 2
8 128
16 12345
样例输出：
12
7
512
3
255
36358
题型：二叉树的应用
注：编号顺序为从上到下，从左到右，且可知，编号为K的节点的左子节点的编号为 2*K 右节点编号为2*K+1，球数为偶数时，最
后一个小球进入右节点，当小球个数为奇数时，最后一个小球进入左节点
解题方法：通过观察不难发现，当球数为偶数个时，最后一个小球从根节点（编号为 K）出发且向右子树（右节点）落，且此时最后一个小球为第 n/2个
进入右子树（右节点）的小球，且为最后一个进入子树的小球，因此易知，进入右子树的小球个数为n/2个，编号变为了 2*K+1，
再将此节点看作为根节点，易知，此时小球只剩下了 n/2个，再判断小球的奇偶性，再进入下一个节点，依次计算，直到小球落
到最后一层树，就结束计算
当小球个数为奇数时，与偶数球数的推理方法相同
*/

#include<iostream>
#include<string>
using namespace std;
int main(){
	int N, I;
	while (~scanf("%d%d",&N,&I)){
		int k = 1;
		N = N - 1;
		while (N--){
			if (I%2){
				k = k * 2;
				I = (I + 1) / 2;
			}
			else{
				k = 2 * k + 1;
				I = I / 2;
			}
		}
		printf("%d\n",k);
	}
}