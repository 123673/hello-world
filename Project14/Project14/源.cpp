/*题目：Red and Black 
题目描述：有一个长方形的房间，上面铺着方形的瓷砖。每个瓷砖都是红色的或黑色的。
一个男人站在一块黑色瓷砖上。从瓷砖，他可以移动到四个相邻的瓷砖之一。但他不能在红色瓷砖上移动，只
能在黑色瓷砖上移动。编写一个程序来计算黑瓷砖的数量，他可以通过重复上面描述的动作来达到。
input：

输入由多个数据集组成。数据集以包含两个正整数W和H的直线开始；W和H分别是x方向和y方向上的瓷砖数。
W和H不超过20。数据集中有H多行，每一行包括W个字符。每个字符表示瓷砖的颜色如下。
‘.’-黑色瓷砖
‘#’-红色瓷砖
‘@’-黑色瓷砖上的男人(在一组数据中正好只出现一次)
输入的末尾由两个零组成的一行表示。
output：

对于每个数据集，您的程序应该输出一行，其中包含他可以从初始瓷砖(包括它本身)到达的瓷砖数量。
Sample Input：
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0
Sample Output：
45
59
6
13
题型：深度优先搜索(dfs)
题目思路：利用递归函数遍历所有符合的点的个数，最后输出符合题意的点的个数
本次解题出现的问题：
1.dfs()函数里面递归的条件有两种表示方法：第一种方法直接判断，符合条件就进入条件，然后递归
第二种方法，先对不符合的条件进行判断，如果一旦有条件不符合就退出函数，本题使用的是第一种方法
2.如何保存符合条件的点数：注意：递归函数归的时候，里面的变量也会返回上一个状态，所以74，75行的变量rr,cc
不能用r,c来保存
3.不能把num++写在if()条件之外，否则num不会改变，因为递归会将变量归为初始状态
*/
#include<iostream>
#include<cstring>
char pic[100][100];
int m, n, idx[100][100] = {0};
int dir[4][2] = { { 0, 1 }, { 0, -1 }, { 1, 0 }, {-1, 0 } };
int num = 0;
using namespace std;
void dfs(int r, int c){	
		 for (int k = 0; k < 4; k++){
		 int rr = r + dir[k][0];
		 int cc = c + dir[k][1];
		 if (rr >= 0&&rr < m&&cc >= 0&&cc < n&&pic[rr][cc]=='.'&&idx[rr][cc]==0){
			  num++;
			  idx[rr][cc] = 1;
		      dfs(rr,cc);
		      } 
	     }	
}
int main(){
	 while(~scanf("%d%d",&n,&m)){
		if (n == 0 && m == 0) break;
		for(int i = 0; i < m; i++)  scanf("%s",pic[i]);
		memset(idx,0,sizeof(idx));
		for (int i = 0; i < m; i++)
		    for (int j = 0; j < n; j++)
			     if (pic[i][j] == '@'){
				 idx[i][j] = 1;
				 num = 1;
				 dfs(i,j);
			}		    
	printf("%d\n",num);
	}
	 return 0;
}